from pathlib import Path
path = Path(r"C:\codex-test\logs\FXプロジェクト\config_loader.py")
text = path.read_text(encoding="utf-8")
old = 'from functools import lru_cache\nfrom pathlib import Path\nimport yaml\n\n_CONFIG_PATH = Path(__file__).with_name("config.yaml")\n\n\nclass ConfigError(RuntimeError):\n    """Raised when the static configuration cannot be parsed."""\n\n\n\ndef _parse_yaml(text: str) -> dict[str, object]:\n    try:\n        data = yaml.safe_load(text) or {}\n        if not isinstance(data, dict):\n            raise TypeError("top-level YAML must be an object")\n        return data\n    except yaml.YAMLError as exc:\n        raise ConfigError(f"failed to parse config: {exc}") from exc\n'\nnew = 'from functools import lru_cache\nfrom pathlib import Path\nimport ast\n\ntry:\n    import yaml  # type: ignore\nexcept ModuleNotFoundError:  # pragma: no cover - fallback when PyYAML missing\n    yaml = None\n\n_CONFIG_PATH = Path(__file__).with_name("config.yaml")\n\n\nclass ConfigError(RuntimeError):\n    """Raised when the static configuration cannot be parsed."""\n\n\n_DEF_NULLS = {"null", "none", ""}\n\n\ndef _parse_scalar(value: str):\n    lower = value.lower()\n    if lower == "true":\n        return True\n    if lower == "false":\n        return False\n    if lower in _DEF_NULLS:\n        return None\n    if value.startswith("[") and value.endswith("]"):\n        return ast.literal_eval(value)\n    try:\n        if "." in value:\n            return float(value)\n        return int(value)\n    except ValueError:\n        return value\n\n\ndef _fallback_yaml(text: str) -> dict[str, object]:\n    root: dict[str, object] = {}\n    stack: list[tuple[int, dict[str, object]]] = [(-2, root)]\n    for raw_line in text.splitlines():\n        if not raw_line.strip() or raw_line.lstrip().startswith("#"):\n            continue\n        indent = len(raw_line) - len(raw_line.lstrip(" "))\n        if indent % 2 != 0:\n            raise ConfigError(f"invalid indentation: {raw_line!r}")\n        line = raw_line.strip()\n        key, sep, remainder = line.partition(":")\n        if not sep:\n            raise ConfigError(f"missing ':' in line: {raw_line!r}")\n        key = key.strip()\n        value = remainder.strip()\n        while indent <= stack[-1][0]:\n            stack.pop()\n        current = stack[-1][1]\n        if value == "":\n            nested: dict[str, object] = {}\n            current[key] = nested\n            stack.append((indent, nested))\n        else:\n            current[key] = _parse_scalar(value)\n    return root\n\n\ndef _parse_yaml(text: str) -> dict[str, object]:\n    if yaml is not None:\n        try:\n            data = yaml.safe_load(text) or {}\n            if not isinstance(data, dict):\n                raise TypeError("top-level YAML must be an object")\n            return data\n        except yaml.YAMLError as exc:  # pragma: no cover - handled via tests\n            raise ConfigError(f"failed to parse config: {exc}") from exc\n    return _fallback_yaml(text)\n'
text = text.replace(old, new, 1)
path.write_text(text, encoding="utf-8")



